<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Beat the Box</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@600;700&family=Quicksand:wght@400;600;700&display=swap" rel="stylesheet">
<style>
* { box-sizing: border-box; }
:root{
  --sage:#9BB59F;
  --cream:#FFF7E9;
  --charcoal:#2E2E2E;
  --clay:#C57B57;
  --good:#3a7f5a;
}
html,body{height:auto; min-height:100%;}
body{
  margin:0; background:var(--cream); color:var(--charcoal);
  font-family:'Quicksand', system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Noto Sans', 'Helvetica Neue', Arial;
  display:flex; justify-content:center; overflow-x:hidden;
}
#app{width:min(980px,100%); padding:12px; position:relative;}
.header{display:flex; align-items:center; justify-content:space-between; padding:8px 4px 12px; border-bottom:2px solid rgba(46,46,46,.08);}
.title h1{font-family:'Noto Serif JP', serif; margin:0; font-size:28px; letter-spacing:.5px;}
.title .tagline{margin:2px 0 0 0; opacity:.75;}
.stats{ display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
.stat{ background:white; border:2px solid var(--sage); border-radius:14px; padding:6px 10px; display:flex; gap:8px; align-items:center; box-shadow:0 2px 0 rgba(0,0,0,.04);}
.stat span{ opacity:.7; }
.stat strong{ font-size:18px; }

.board-wrap{ display:grid; grid-template-columns: 1fr 200px; gap:12px; margin-top:12px;}
.grid{ display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; padding:8px; background:#ffffffb3; border:2px solid var(--sage); border-radius:18px;}
.card{ user-select:none; border-radius:14px; border:2px solid var(--sage); background:white; height:120px; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:22px; position:relative; box-shadow:0 4px 0 rgba(0,0,0,.05); transition: transform .12s ease, opacity .12s ease; transform-style: preserve-3d; perspective: 800px;}
.card.active:hover{ transform: translateY(-2px); }
.card.inactive{ background: var(--sage); color:white;}
.card .label{ position:absolute; bottom:6px; right:10px; font-size:12px; opacity:.6;}
.card.selected{ outline: 3px solid var(--clay); }
.card.revive-target{ outline: 3px dashed var(--clay); }
.card.correct{ box-shadow: 0 0 0 3px rgba(58,127,90,.45), 0 4px 0 rgba(0,0,0,.06); }

.deck-panel{ background:#ffffffb3; border:2px solid var(--sage); border-radius:18px; padding:10px; display:flex; flex-direction:column; gap:10px; align-items:center; position:relative;}
.deck-card{ width:140px; height:180px; border-radius:16px; border:2px solid var(--sage); display:flex; align-items:center; justify-content:center; font-family:'Noto Serif JP', serif; font-weight:700; font-size:34px; color:var(--sage); background: radial-gradient(ellipse at top left, #ffffff 0%, #f6fff8 90%); box-shadow:0 6px 0 rgba(0,0,0,.05); transform-style:preserve-3d; perspective:800px; position:relative; overflow:hidden;}
.deck-card::after{ content:""; position:absolute; inset:10px; border-radius:12px; border:2px dashed var(--sage); opacity:.6;}
.deck-sub{ position:absolute; bottom:8px; font-size:12px; opacity:.6; color:var(--charcoal); }
.counters, .scores { width:100%; font-size:14px; display:flex; flex-direction:column; gap:6px; }

.controls{ margin-top:12px; display:flex; gap:10px; justify-content:space-between;}
.btn{ flex:1; background:var(--sage); color:white; border:none; padding:14px 12px; border-radius:14px; font-weight:700; font-size:16px; box-shadow:0 4px 0 rgba(0,0,0,.08); cursor:pointer;}
.btn:active{ transform: translateY(1px); box-shadow:0 2px 0 rgba(0,0,0,.08); }
.btn.secondary{ background:var(--charcoal); }
.footer{ margin-top:8px; display:flex; align-items:center; gap:12px;}
.footer .hint{ opacity:.7; }

.overlay{ position:fixed; inset:0; background:rgba(0,0,0,.28); display:flex; align-items:center; justify-content:center; z-index:20;}
.overlay.hidden{ display:none; }
.modal{ background:white; border:2px solid var(--sage); border-radius:16px; padding:16px; width:min(380px,90%);}
.modal-text{ margin-bottom:10px; }

/* Flying card */
.flying-card{
  position:fixed; z-index:15; width:120px; height:160px;
  border-radius:14px; border:2px solid var(--sage);
  background:white; display:flex; align-items:center; justify-content:center;
  font-weight:700; font-size:26px; box-shadow:0 6px 0 rgba(0,0,0,.08);
  transform: translate(-50%,-50%);
}

/* Banners: extended to ~2.5s */
.banner{
  position:fixed; left:50%; top:14%; transform:translateX(-50%);
  background:white; color:var(--charcoal);
  border:2px solid var(--sage); border-radius:16px;
  padding:10px 14px; font-weight:800; font-size:18px; z-index:30;
  box-shadow:0 8px 0 rgba(0,0,0,.06);
  animation: bannerPop 2500ms ease forwards;
  text-align:center;
}
@keyframes bannerPop{
  0%{ transform: translate(-50%,-10px) scale(.88); opacity:0; }
  10%{ opacity:1; transform: translate(-50%,0) scale(1.02); }
  80%{ opacity:1; transform: translate(-50%,0) scale(1.00); }
  100%{ opacity:0; transform: translate(-50%,-6px) scale(.98); }
}

/* Emoji fireworks: ~2.5s with pop + stagger */
.cele{
  position:fixed; z-index:25; font-size:22px; pointer-events:none;
  animation: fireworks 2500ms ease-out forwards;
  transform-origin: center;
}
@keyframes fireworks{
  0%{ transform: translateY(12px) scale(0.3); opacity:0; }
  8%{ opacity:1; transform: translateY(0) scale(1.05); }
  20%{ transform: translateY(-10px) scale(1.0); }
  70%{ transform: translateY(-80px) scale(1.06); opacity:1; }
  100%{ transform: translateY(-120px) scale(0.98); opacity:0; }
}

/* Animations */
@keyframes shake {
  10%, 90% { transform: translateX(-1px); }
  20%, 80% { transform: translateX(2px); }
  30%, 50%, 70% { transform: translateX(-4px); }
  40%, 60% { transform: translateX(4px); }
}
.anim-shake{ animation: shake 300ms ease-in-out; }

@keyframes flipY {
  0% { transform: rotateY(0deg); }
  100% { transform: rotateY(180deg); }
}
.anim-flip{ animation: flipY 280ms ease-in; }

@keyframes deal {
  0% { transform: translateY(-8px) scale(0.98); opacity:.0; }
  100% { transform: translateY(0) scale(1); opacity:1; }
}
.anim-deal{ animation: deal 200ms ease-out; }

/* --- Responsive Tweaks --- */
@media (max-width: 900px){
  .board-wrap{ grid-template-columns:1fr; }
  .deck-panel{ order: 2; }
  .grid{ order: 1; }
}
@media (max-width: 480px){
  .grid{ gap:10px; padding:8px; }
  .card{
    height: clamp(88px, 24vw, 120px);
    font-size: clamp(18px, 5.3vw, 22px);
    border-radius: 12px;
  }
  .card .label{ font-size: 11px; }
  .deck-card{
    width: clamp(120px, 38vw, 160px);
    height: clamp(150px, 48vw, 200px);
    font-size: clamp(26px, 7vw, 34px);
    border-radius: 14px;
  }
  .controls .btn{ padding: 14px 10px; font-size: 16px; }
  .stats .stat{ padding: 6px 8px; }
  #app{ padding-bottom: calc(12px + env(safe-area-inset-bottom)); }
}
</style>
</head>
<body>
<div id="app">
  <header class="header">
    <div class="title">
      <h1>Beat the Box</h1>
      <p class="tagline">Can you Beat the Box?!</p>
    </div>
    <div class="stats">
      <div class="stat"><span>‚ù§Ô∏è Bonus</span><strong id="bonusLives">0</strong></div>
      <div class="stat"><span>üÇ† Deck</span><strong id="deckCount">43</strong></div>
      <div class="stat"><span>üî• Streak</span><strong id="streakCount">0</strong></div>
      <div class="stat"><span>üèÜ Longest</span><strong id="longestStreak">0</strong></div>
    </div>
  </header>

  <main class="board-wrap">
    <section class="grid" id="grid"></section>
    <aside class="deck-panel">
      <div class="deck-card" id="deckCard">BTB<div class="deck-sub">Top of deck</div></div>
      <div class="counters">
        <div>Deck Left: <strong id="deckCountSide">43</strong></div>
        <div>Piles Down: <strong id="pilesDownCount">0</strong>/9</div>
      </div>
      <div class="scores">
        <div>Best Win: <strong id="bestWin">‚Äî</strong></div>
        <div>Best Loss: <strong id="bestLoss">‚Äî</strong></div>
        <div>Last Game: <strong id="lastGame">‚Äî</strong></div>
      </div>
    </aside>
  </main>

  <section class="controls">
    <button id="btnHigher" class="btn">Higher</button>
    <button id="btnLower" class="btn">Lower</button>
    <button id="btnSame" class="btn">Same</button>
  </section>

  <footer class="footer">
    <button id="btnNew" class="btn secondary">New Game</button>
    <span class="hint">Tap a face-up pile to select once. Deck is always face-down.</span>
  </footer>
</div>

<div id="overlay" class="overlay hidden">
  <div class="modal">
    <div id="overlayText" class="modal-text">Select an inactive pile to flip active.</div>
    <button id="overlayClose" class="btn">Okay</button>
  </div>
</div>

<script>
// --- Sound (WebAudio) ---
let AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();
function playClick(){
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = 'triangle'; o.frequency.value = 520;
  g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.08, audioCtx.currentTime + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.12);
  o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + 0.14);
}
function playFlip(){
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = 'square'; o.frequency.value = 280;
  g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.09, audioCtx.currentTime + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.18);
  o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + 0.2);
}

// --- Elements ---
const gridEl = document.getElementById('grid');
const deckCountEl = document.getElementById('deckCount');
const deckCountSideEl = document.getElementById('deckCountSide');
const pilesDownCountEl = document.getElementById('pilesDownCount');
const bonusLivesEl = document.getElementById('bonusLives');
const streakEl = document.getElementById('streakCount');
const longestEl = document.getElementById('longestStreak');
const deckCardEl = document.getElementById('deckCard');
const btnHigher = document.getElementById('btnHigher');
const btnLower  = document.getElementById('btnLower');
const btnSame   = document.getElementById('btnSame');
const btnNew    = document.getElementById('btnNew');
const overlay = document.getElementById('overlay');
const overlayText = document.getElementById('overlayText');
const overlayClose = document.getElementById('overlayClose');
const bestWinEl = document.getElementById('bestWin');
const bestLossEl = document.getElementById('bestLoss');
const lastGameEl = document.getElementById('lastGame');

// --- Scores persistence ---
const LS_KEY = 'btb_scores_v1';
function loadScores(){ try{ return JSON.parse(localStorage.getItem(LS_KEY))||{bestWin:null,bestLoss:null,lastGame:null,longestStreak:0}; }catch(e){ return {bestWin:null,bestLoss:null,lastGame:null,longestStreak:0}; } }
function saveScores(d){ localStorage.setItem(LS_KEY, JSON.stringify(d)); }
function updateScoreUI(){
  const s = loadScores();
  bestWinEl.textContent = s.bestWin==null ? '‚Äî' : s.bestWin + ' piles up';
  bestLossEl.textContent = s.bestLoss==null ? '‚Äî' : s.bestLoss + ' cards left';
  lastGameEl.textContent = s.lastGame ?? '‚Äî';
  longestEl.textContent = s.longestStreak || 0;
}

// --- Game state ---
const SUITS = ['‚ô†','‚ô•','‚ô¶','‚ô£'];
let deck=[], piles=[], selectedIndex=null, bonusLives=0, gameOver=false;
let currentStreak = 0;
// Recovery banner after wrong
let recovering = false;
let recoverCount = 0;

function makeDeck(){
  const d=[]; for(let v=1; v<=13; v++){ for(let s of SUITS){ d.push({value:v,suit:s}); } } return d;
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function valueLabel(v){ return v===1?'A':v===11?'J':v===12?'Q':v===13?'K':String(v); }
function cardText(c){ return c ? valueLabel(c.value) + ' ' + c.suit : 'BTB'; }

function render(){
  gridEl.innerHTML='';
  piles.forEach((p,idx)=>{
    const el=document.createElement('div');
    el.className='card '+(p.active?'active':'inactive');
    el.dataset.index=idx;
    el.innerHTML = p.active
      ? `<div class="face">${valueLabel(p.value)} <span style="opacity:.6">${p.suit}</span></div><div class="label">Pile ${idx+1}</div>`
      : `<div class="back">BTB</div><div class="label">Pile ${idx+1}</div>`;
    if(p.active){
      el.addEventListener('click',()=>{ selectedIndex=idx; playClick(); highlightSelection(); });
    }
    gridEl.appendChild(el);
  });
  deckCountEl.textContent = deck.length;
  deckCountSideEl.textContent = deck.length;
  pilesDownCountEl.textContent = piles.filter(p=>!p.active).length;
  bonusLivesEl.textContent = bonusLives;
  streakEl.textContent = currentStreak;
  updateScoreUI();
}
function highlightSelection(){
  [...document.querySelectorAll('.card')].forEach((c,i)=> c.classList.toggle('selected', i===selectedIndex));
}
function flipDeckAnim(){
  deckCardEl.classList.remove('anim-flip'); void deckCardEl.offsetWidth; deckCardEl.classList.add('anim-flip');
}
function correctGlow(el){
  el.classList.add('correct');
  setTimeout(()=> el.classList.remove('correct'), 350);
}

function updatePileFace(idx){
  const el = gridEl.children[idx];
  if(!el) return;
  const p = piles[idx];
  if(!p || !p.active) return;
  el.innerHTML = `<div class="face">${valueLabel(p.value)} <span style="opacity:.6">${p.suit}</span></div><div class="label">Pile ${idx+1}</div>`;
}


// Flying card from deck to target
function flyCard(content, targetEl, cb){
  const rectFrom = deckCardEl.getBoundingClientRect();
  const rectTo = targetEl.getBoundingClientRect();
  const fc = document.createElement('div');
  fc.className = 'flying-card';
  fc.style.left = (rectFrom.left + rectFrom.width/2) + 'px';
  fc.style.top  = (rectFrom.top + rectFrom.height/2) + 'px';
  fc.textContent = content;
  document.body.appendChild(fc);
  requestAnimationFrame(()=>{
    fc.style.transition = 'transform 300ms ease-in-out';
    const dx = (rectTo.left + rectTo.width/2) - (rectFrom.left + rectFrom.width/2);
    const dy = (rectTo.top + rectTo.height/2) - (rectFrom.top + rectFrom.height/2);
    fc.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  });
  setTimeout(()=>{ document.body.removeChild(fc); cb&&cb(); }, 320);
}

// Banners
function showBanner(text){
  const b = document.createElement('div');
  b.className = 'banner';
  b.textContent = text;
  document.body.appendChild(b);
  setTimeout(()=> b.remove(), 2550);
}

// Celebrations / Mourning with stagger + pop
function spawnEmojiBurst(items, duration=2500, count=8){
  const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
  for(let i=0;i<count;i++){
    const el = document.createElement('div');
    el.className='cele';
    el.textContent = items[i % items.length];
    const x = Math.random()*vw*0.8 + vw*0.1;
    const y = window.innerHeight*0.7 + Math.random()*40;
    el.style.left = x+'px';
    el.style.top = y+'px';
    el.style.animationDuration = duration+'ms';
    el.style.animationDelay = (i*80)+'ms'; // stagger like fireworks
    document.body.appendChild(el);
    setTimeout(()=> el.remove(), duration + i*80 + 100);
  }
}
function celebrate(level){
  const items = level===20 ? ['‚ú®','ü§Ø','üèÜ','üåü','YOU LEGEND!'] :
                 level===10 ? ['‚≠ê','üëè','NICE!','üåü','üëç'] :
                 ['üíö','‚ú®','NICE!','üëç','üéâ'];
  spawnEmojiBurst(items, 2500, 10);
}
function mourn(){
  const items = ['ü™¶','üëª','üò≠','üíÄ','ü™¶','üëª','üò≠','üíÄ'];
  spawnEmojiBurst(items, 2500, 10);
}

// Wrong guess
function handleWrong(idx){
  const el = gridEl.children[idx];
  if(bonusLives>0){
    showOverlay('Wrong ‚Äî use a Bonus Life to keep the pile up?');
    const prev = overlayClose.onclick;
    overlayClose.onclick = ()=>{
      bonusLives -= 1;
      overlay.classList.add('hidden');
      overlayClose.onclick = prev || null;
      render();
    };
  }else{
    // Enter recovery mode
    recovering = true;
    recoverCount = 0;
    currentStreak = 0; // reset streak
    streakEl.textContent = currentStreak;
    el.classList.add('anim-shake');
    mourn();
    // Show revealed card for ~1.2s before flipping inactive
    setTimeout(()=>{
      piles[idx].active=false;
      render();
      const el2 = gridEl.children[idx];
      el2.classList.add('anim-flip');
      if(piles.every(p=>!p.active)) endGame(false);
    }, 1200);
  }
}

function endGame(win){
  gameOver=true;
  const activeCount = piles.filter(p=>p.active).length;
  const cardsLeft = deck.length;
  const s = loadScores();
  if(win){
    if(s.bestWin==null || activeCount > s.bestWin) s.bestWin=activeCount;
    s.lastGame = `Win ‚Ä¢ ${activeCount} piles up`;
    showOverlay(`You win! üéâ  Piles still up: ${activeCount}`);
  }else{
    if(s.bestLoss==null || cardsLeft < s.bestLoss) s.bestLoss=cardsLeft;
    s.lastGame = `Loss ‚Ä¢ ${cardsLeft} cards left`;
    showOverlay(`You lost üí•  All piles down. Cards left: ${cardsLeft}`);
  }
  if((s.longestStreak||0) < currentStreak) s.longestStreak = currentStreak;
  saveScores(s); render();
}

// Overlay helpers
function showOverlay(text){ overlayText.textContent=text; overlay.classList.remove('hidden'); }
overlayClose.addEventListener('click',()=> overlay.classList.add('hidden'));

// Guess resolution
function resolveGuess(kind){
  if(gameOver) return;
  if(selectedIndex==null){ showBanner('Tap a face-up pile to select it. Selection persists.'); return; }
  const pile = piles[selectedIndex];
  if(!pile.active){ showBanner('That pile is inactive. Pick another.'); return; }
  if(deck.length===0){ endGame(true); return; }

  // Special banner: "UNDAH DA QUEEN" when choosing Lower on a Queen
  if(kind==='lower' && pile.value===12){
    showBanner('üåäüåäüßú‚Äç‚ôÄÔ∏èüßú‚Äç‚ôÄÔ∏èüëëüëë  UNDAH DA QUEEN  üåäüåäüßú‚Äç‚ôÄÔ∏èüßú‚Äç‚ôÄÔ∏èüëëüëë');
  }

  // draw hidden card
  const drawn = deck.pop();
  playFlip();
  flipDeckAnim();

  const pileEl = gridEl.children[selectedIndex];
  const drawnText = cardText(drawn);

  let correct=false;
  if(kind==='higher') correct = drawn.value > pile.value;
  if(kind==='lower')  correct = drawn.value < pile.value;
  if(kind==='same')   correct = drawn.value === pile.value;

  // Animate flying face from deck to pile
  flyCard(drawnText, pileEl, ()=>{
    if(kind==='same'){
      if(correct){
        piles[selectedIndex] = {...drawn, active:true};
        updatePileFace(selectedIndex);
        correctGlow(pileEl);
        currentStreak += 1;
        if(recovering){ recoverCount += 1; if(recoverCount===3){ showBanner('back in it'); recovering=false; } }
        maybeCelebrate(currentStreak);
        postCorrectPush();
      }else{
        handleWrong(selectedIndex);
      }
    }else{
      if(correct){
        piles[selectedIndex] = {...drawn, active:true};
        updatePileFace(selectedIndex);
        correctGlow(pileEl);
        currentStreak += 1;
        if(recovering){ recoverCount += 1; if(recoverCount===3){ showBanner('back in it'); recovering=false; } }
        maybeCelebrate(currentStreak);
      }else{
        handleWrong(selectedIndex);
      }
    }

    // update longest streak persistently
    const s = loadScores();
    if((s.longestStreak||0) < currentStreak){ s.longestStreak = currentStreak; saveScores(s); }
    longestEl.textContent = loadScores().longestStreak || 0;

    // Win/Lose checks
    if(!gameOver && piles.every(p=>!p.active)){ endGame(false); return; }
    if(!gameOver && deck.length===0){ endGame(true); return; }

    deckCountEl.textContent = deck.length;
    deckCountSideEl.textContent = deck.length;
    streakEl.textContent = currentStreak;
    setTimeout(()=>{ render(); highlightSelection(); }, 0);
  });
}

function postCorrectPush(){
  const inactive = piles.map((p,i)=>p.active?null:i).filter(x=>x!==null);
  if(inactive.length>0){
    showOverlay('PUSH! Select an inactive pile to flip active.');
    const handler = (e)=>{
      const idx = Number(e.currentTarget.dataset.index);
      if(!piles[idx].active){
        piles[idx].active = true;
        overlay.classList.add('hidden');
        gridEl.querySelectorAll('.card').forEach(c=>c.removeEventListener('click', handler));
        render();
        gridEl.children[idx].classList.add('anim-flip');
      }
    };
    gridEl.querySelectorAll('.card').forEach((c,i)=>{
      if(!piles[i].active){ c.addEventListener('click', handler); c.classList.add('revive-target'); }
    });
  }else{
    bonusLives += 1;
  }
}

// Events
btnHigher.addEventListener('click', ()=>{ playClick(); resolveGuess('higher'); });
btnLower .addEventListener('click', ()=>{ playClick(); resolveGuess('lower');  });
btnSame  .addEventListener('click', ()=>{ playClick(); resolveGuess('same');   });
btnNew   .addEventListener('click', ()=>{ playClick(); newGame(); });

function newGame(){
  gameOver=false; bonusLives=0; deck = shuffle(makeDeck());
  piles=[]; for(let i=0;i<9;i++){ piles.push({...deck.pop(), active:true}); }
  selectedIndex=null; currentStreak=0; recovering=false; recoverCount=0;
  render();
}
updateScoreUI(); newGame();
</script>
</body>
</html>
